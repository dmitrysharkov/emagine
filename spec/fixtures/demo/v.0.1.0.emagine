PUBLIC MODULE demo, '0.1.0' DO

    IMPORT base, '>=1.0.0'
    IMPORT std.datetime, '>=1.0.1' AS dt
    IMPORT std.tasks, '>=1.0.1' AS tasks
    IMPORT std.strings, '>=1.0.0' AS str
    IMPORT std.regexp AS re
    IMPORT std.arrays AS arr

    ALIAS base.TPositiveInteger AS TPositiveInteger

    CONFIG DO
        ATTR dbPassword: String
        ATTR dbUser: String

    IMPORT std.db.postgres AS db
    CONFIGURE db(username: @@dbUser, password: @@dbPassword, lost: 'localhost', db: 'mydb')

    ALIAS db.execute AS sql

    ALIAS base.TPositiveInteger AS TPositiveInteger

    DOC This thing looks really great. Hello world.
        Here we can leave comments
        Event more comments. Looks cool ha?

    PUBLIC TASK ProcSimpleWorkflow : Integer DO
        INTERFACE INHERITS Interface

        RECEIVES DO
            ATTR customerId AS TPositiveInteger
            ATTR maxMessages: TPositiveInteger DEFAULT 5
            ATTR daysBetweenMessages: TPositiveInteger DEFAULT 3

        LET $i = 0
        LET $continue = TRUE
        LET @customerId = @params.customerId
        WHILE ($i < $maxMessages) AND $continue
            $continue = EXEC ProcFetchCustomer(@params.customerId) MAP filterCustomerState
            IF $continue
                LET $templateName = "message-template-{{ $i + 1 }}"

                EXEC ProcSendMessageToCustomer($customerId, templateName: $templateName)

                LET $nextMessageTime = dt.today() + dt.period(days: $daysBetweenMessages)

                LET $observeStatus = DELEGATE EvCustomerStatusChanged(@customerId)
                LET $observeAlarm = DELEGATE EvAlarmClock($nextMessageTime)

                LET $oneOf = tasks.oneOf($waitForCustomerStatusChange, $waitForXDays)

                AWAIT $oneOf

                $i = $i + 1

        LET x = { $a, $b, $c, a: $g, b: $c, c: 10 }
        LET y = ['1', '2', '3', '4']



    PRIVATE FUNCTION filterCustomerFields(active AS Boolean) : Boolean DO
        RET @params.active

    # if short for applied then

    PRIVATE PROCEDURE ProcSendMessageToCustomer(customerId AS Integer) : TCustomerCortege DO
        LANG 'ruby', '1.2.2' DO
            def call(customer_id)
                return { is: 'customer_id', email: 'test@text.com', active: true }
            end

    PUBLIC TYPE TCustomerCortege INHERITS Cortege DO
        ATTR customerId: Integer
        ATTR email: TEmailSting
        ATTR active: Boolean

    PRIVATE CONST ConstEmailRegexp:Regexp = STRING DO
        (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x
        0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]
        *[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)
        {3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x2
        1-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])'

    PUBLIC TYPE TEmailString INHERITS String DO
        CONSTRAINT 'has_to_be_valid_address' AS PIPE DO
            LAMBDA str.notEmpty
            LAMBDA re.check(ConstEmailRegexp)

    PUBLIC CONST ConstStatusesArray = ['active', 'inactive']

    PUBLIC STATUS TStatusString INHERITS String DO
        CONSTRAINT 'unexpected' arr.includes(ConstStatusesArray)



